/*###############################################################
## MODULE: test_CSW.cpp
## VERSION: 1.0 
## SINCE: 2015-09-05
##      
#################################################################
## Edited by MacVim
## Class Info auto-generated by Snippet 
################################################################*/

#include "MSA_Convex.h"
string seq_1 = "AGTCAGCCTTGACCCTAGCT";

/* This file aims at making test on cube_smith_waterman */
int main (int argn, char** argv) {
    // 1. configure tested environment
    string data_dna(seq_1);
    int T1 = data_dna.length();
    int T2 = data_dna.length();
    int T3 = NUM_DNA_TYPE;
    int T4 = NUM_MOVEMENT;

    Tensor4D S(T1, Tensor(T2, Matrix(NUM_DNA_TYPE,
                    vector<double>(NUM_MOVEMENT, 0.0)))); // the resolved searching direction
    Trace trace(0, Cell(3));  // the resolved cell path
    Tensor4D M(T1, Tensor(T2, Matrix(NUM_DNA_TYPE,
                    vector<double>(NUM_MOVEMENT, 0.0)))); // pre-defined model preference
    Tensor4D C(T1, Tensor(T2, Matrix(NUM_DNA_TYPE,
                    vector<double>(NUM_MOVEMENT, 0.0)))); // global constant error
    Sequence data_seq(data_dna.begin(), data_dna.end()) ;  // data_seq for testing

    for (int d = 0; d < data_seq.size(); d ++)
        cout << data_seq[d] ;
    cout << endl;

    for (int i = 0; i < T1; i ++) {
        for (int j = 0; j < T2; j ++) {
            for (int k = 0; k < T3; k ++) {
                for (int m = 0; m < T4; m ++) {
                    if (m == INS_BASE_IDX) 
                        C[i][j][k][m] = C_I;
                    else if (DEL_BASE_IDX <= m and m < MTH_BASE_IDX) 
                        C[i][j][k][m] = C_D;
                    else if (MTH_BASE_IDX <= m and m < NUM_MOVEMENT) {
                        if (k == dna2T3idx(data_dna[i]))
                            C[i][j][k][m] = C_M;
                        else
                            C[i][j][k][m] = C_MM;
                    }
                }
            }
        }
    }

    // 2. invoke smith waterman algorithm
    cube_smith_waterman (S, trace, M, C, data_seq);

    // 3. show the result
    // 3a. tuple view
    for (int i = 0; i < trace.size(); i ++) 
        cout << trace[i].toString() << endl;
    // 3b. sequence view
    cout << "1st_aligned_DNA: ";
    for (int i = 0; i < trace.size(); i ++) 
        cout << trace[i].acidA;
    cout << endl;
    cout << "2nd_aligned_DNA: ";
    for (int i = 0; i < trace.size(); i ++) 
        cout << trace[i].acidB;
    cout << endl;
    return 0;
}
