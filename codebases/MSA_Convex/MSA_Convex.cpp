/*###############################################################
## MODULE: MSA_Convex.cpp
## VERSION: 1.0 
## SINCE 2015-09-01
## DESCRIPTION: 
##      
#################################################################
## Edited by MacVim
## Class Info auto-generated by Snippet 
################################################################*/


#include "MSA_Convex.h"


/* Debugging option */
//#define RECURSION_TRACE

/* Define Scores of all Actions */
const double MATCH_SCORE = +2;
const double MISMATCH_SCORE = -1;
const double INSERTION_SCORE = -1;
const double DELETION_SCORE = -1;
const char GAP_NOTATION = '-';

/* 
   The first sequence is observed. 
   The second sequence is the one to be aligned with the observed one.
   */
void usage () { cout << "./PSA_CUBE [seq_file]" << endl;
    cout << "seq_file should contain two DNA sequence in its first line and second line. " << endl;
    cout << "The first sequence is observed. " << endl;
    cout << "The second sequence is the one to be aligned with the observed one." << endl;
}

/* FrankWolf Algorithm */
/*{{{*/
//void FrankWolf () {
//    int nRow = tensor.size();
//    int nCol = tensor[0].size();
//    int nDep = tensor[0][0].size();
//    // 1. fill in the tensor
//    double max_score = MIN_DOUBLE;
//    int max_i = -1, max_j = -1;
//    for (int i = 0; i < nRow; i ++) {
//        for (int j = 0; j < nCol; j ++) {
//            for (int k = 0; k < nDep; k ++) {
//                tensor[i][j][k].row_index = i;
//                tensor[i][j][k].col_index = j;
//                tensor[i][j][k].dep_index = k;
//                if (i == 0 or j == 0 or k == 0) continue;
//                char acidA = seqA[j-1];
//                char acidB = seqB[i-1];
//                // 1a. get max matach/mismatch score
//                double mscore = isMatch2(acidA,acidB)?MATCH_SCORE:MISMATCH_SCORE;
//                double mm_score = tensor[i-1][j-1][].score + mscore;
//                // 1b. get max insertion score
//                double ins_score = MIN_DOUBLE;
//                for (int l = 1; j - l > 0 ; l ++) 
//                    ins_score = max(ins_score, tensor[i][j-l].score + l * INSERTION_SCORE);
//                double del_score = MIN_DOUBLE;
//                // 1c. get max deletion score
//                for (int l = 1; i - l > 0 ; l ++) 
//                    del_score = max(del_score, tensor[i-l][j].score + l * DELETION_SCORE);
//                double opt_score = MIN_DOUBLE;
//                // 1d. get optimal action for the current tensor
//                Action opt_action;
//                char opt_acidA, opt_acidB;
//                if (ins_score >= max(mm_score, del_score)) {
//                    opt_score = ins_score;
//                    opt_action = INSERTION;
//                    opt_acidA = acidA;
//                    opt_acidB = GAP_NOTATION;
//                } else if (del_score >= max(mm_score, ins_score)) {
//                    opt_score = del_score;
//                    opt_action = DELETION;
//                    opt_acidA = GAP_NOTATION;
//                    opt_acidB = acidB;
//                } else if (mm_score >= max(ins_score, del_score)) {
//                    opt_score = mm_score;
//                    opt_action = isMatch2(acidA,acidB)?MATCH:MISMATCH;
//                    opt_acidA = acidA;
//                    opt_acidB = acidB;
//                }
//                // 1e. assign the optimal score/action to the cell
//                tensor[i][j][k].score = opt_score;
//                tensor[i][j][k].action = opt_action;
//                tensor[i][j][k].acidA = opt_acidA;
//                tensor[i][j][k].acidB = opt_acidB;
//                // 1f. keep track of the globally optimal cell
//                if (opt_score >= max_score) {
//                    max_score = opt_score;
//                    max_i = i;
//                    max_j = j;
//                    max_k = k;
//                }
//            }
//        }
//    }
//    // 2. trace back
//    cout << "max_i: " << max_i << ", max_j: " << max_j << endl;
//    if (max_i == 0 or max_j == 0) {
//        trace.push_back(tensor[max_i][max_j][max_k]);
//        return; 
//    }
//    int i,j;
//    for (i = max_i, j = max_j; i > 0 and j > 0; ) {
//        trace.insert(trace.begin(), tensor[i][j][k]);
//        switch (tensor[i][j][k].action) {
//            case MATCH: i--; j--; break;
//            case MISMATCH: i--; j--; break;
//            case INSERTION: j--; break;
//            case DELETION: i--; break;
//            case UNDEFINED: cerr << "uncatched action." << endl; break;
//        }
//    }
//    if (i == 0 and j == 0) return;
//    // special cases
//    else 
//        trace.insert(trace.begin(), tensor[1][1]);
//}
/*}}}*/

int get_init_model_length (vector<int>& lenSeqs) {
    int max_seq_length = -1;
    int numSeq = lenSeqs.size(); 
    for (int i = 0; i < numSeq; i ++)
        if (lenSeqs[i] > max_seq_length) 
            max_seq_length = lenSeqs[i];
    return max_seq_length;
}

void tensor5D_init (vector<Tensor4D>& C, SequenceSet& allSeqs, vector<int>& lenSeqs, int init_T2) {
    int numSeq = allSeqs.size();
    for (int n = 0; n < numSeq; n ++) {
        for (int i = 0; i < lenSeqs[n]; i ++) {
            Tensor tmp_tensor (init_T2, Matrix(NUM_DNA_TYPE, vector<double>(NUM_MOVEMENT, 0.0)));
            C[n].push_back(tmp_tensor);
        }
    }
}

void tensor5D_avg (Tensor5D dest, Tensor5D src1, Tensor5D src2) {
    int N = src1.size();
    for (int n = 0; n < N; n ++) {
        int T1 = src1[n].size();
        for (int i = 0; i < T1; i ++) {
            int T2 = src1[n][i].size();
            for (int j = 0; j < T2; j ++) 
                for (int d = 0; d < NUM_DNA_TYPE; d ++) 
                    for (int m = 0; m < NUM_MOVEMENT; m ++)
                        dest[n][i][j][d][m] = 0.5*(src1[n][i][j][d][m] + src2[n][i][j][d][m]);
        }
    }
}
void tensor5D_sub (Tensor5D dest, Tensor5D src1, Tensor5D src2) {
    int N = src1.size();
    for (int n = 0; n < N; n ++) {
        int T1 = src1[n].size();
        for (int i = 0; i < T1; i ++) {
            int T2 = src1[n][i].size();
            for (int j = 0; j < T2; j ++) 
                for (int d = 0; d < NUM_DNA_TYPE; d ++) 
                    for (int m = 0; m < NUM_MOVEMENT; m ++)
                        dest[n][i][j][d][m] = src1[n][i][j][d][m] - src2[n][i][j][d][m];
        }
    }
}
void tensor5D_frob_prod ();
void tensor5D_lin_update ();

void tensor5D_copy (Tensor5D dest, Tensor5D src1) {
    int N = src1.size();
    for (int n = 0; n < N; n ++) {
        int T1 = src1[n].size();
        for (int i = 0; i < T1; i ++) {
            int T2 = src1[n][i].size();
            for (int j = 0; j < T2; j ++) 
                for (int d = 0; d < NUM_DNA_TYPE; d ++) 
                    for (int m = 0; m < NUM_MOVEMENT; m ++)
                        dest[n][i][j][d][m] = src1[n][i][j][d][m];
        }
    }  
}

vector<Tensor4D> CVX_ADMM_MSA (SequenceSet& allSeqs, vector<int>& lenSeqs) {
    // 1. initialization
    int T2 = get_init_model_length (lenSeqs); // model_seq_length
    vector<Tensor4D> Z (numSeq, Tensor4D(0, Tensor(T2, Matrix(NUM_DNA_TYPE,
                        vector<double>(NUM_MOVEMENT, 0.0)))));  // Score for each W_1 .. W_n
    vector<Tensor4D> C (numSeq, Tensor4D(0, Tensor(T2, Matrix(NUM_DNA_TYPE,
                        vector<double>(NUM_MOVEMENT, 0.0)))));  // Score for each W_1 .. W_n
    vector<Tensor4D> W_1 (numSeq, Tensor4D(0, Tensor(T2, Matrix(NUM_DNA_TYPE,
                        vector<double>(NUM_MOVEMENT, 0.0)))));  // Score for each W_1 .. W_n
    vector<Tensor4D> W_2 (numSeq, Tensor4D(0, Tensor(T2, Matrix(NUM_DNA_TYPE,
                        vector<double>(NUM_MOVEMENT, 0.0)))));  // Score for each W_1 .. W_n
    vector<Tensor4D> Y_1 (numSeq, Tensor4D(0, Tensor(T2, Matrix(NUM_DNA_TYPE,
                        vector<double>(NUM_MOVEMENT, 0.0)))));  // Score for each W_1 .. W_n
    vector<Tensor4D> Y_2 (numSeq, Tensor4D(0, Tensor(T2, Matrix(NUM_DNA_TYPE,
                        vector<double>(NUM_MOVEMENT, 0.0)))));  // Score for each W_1 .. W_n
    tensor5D_init (Z, allSeqs, lenSeqs, T2);
    tensor5D_init (C, allSeqs, lenSeqs, T2);
    tensor5D_init (W_1, allSeqs, lenSeqs, T2);
    tensor5D_init (W_2, allSeqs, lenSeqs, T2);
    tensor5D_init (Y_1, allSeqs, lenSeqs, T2);
    tensor5D_init (Y_2, allSeqs, lenSeqs, T2);

    // 2. ADMM iteration
    int iter = 0;
    int MAX_ADMM_ITER = 1000;
    double MU = 1.0;
    for (iter < MAX_ADMM_ITER) {
        // 2a. Subprogram: FrankWolf Algorithm
        
        // 2b. Subprogram: 

        // 2c. update Z: Z = (W_1 + W_2) / 2
        average (Z, W_1, W_2);
        // 2d. update Y_1 and Y_2: Y_1 = 
        lin_update (Y_1, W_1, Z, MU);
        lin_update (Y_2, W_2, Z, MU);
    }
    return Z;
}

int main (int argn, char** argv) {
    // 1. usage
    if (argn < 2) {
        usage();
        exit(1);
    }

    // 2. input DNA sequence file
    SequenceSet allSeqs (0, Sequence());
    ifstream seq_file(argv[1]);
    string tmp_str;
    int numSeq = 0;
    while (getline(seq_file, tmp_str)) {
        Sequence tmp_seq (tmp_str.begin(), tmp_str.end());
        allSeqs.push_back(tmp_seq);
        ++ numSeq;
    }
    seq_file.close();
    cout << "#########################################################" << endl;
    cout << "ScoreMatch: " << MATCH_SCORE;
    cout << ", ScoreInsertion: " << INSERTION_SCORE;
    cout << ", ScoreDeletion: " << DELETION_SCORE;
    cout << ", ScoreMismatch: " << MISMATCH_SCORE << endl;
    for (int n = 0; n < numSeq; n ++) {
        char buffer [50];
        sprintf (buffer, "Seq%5d", n);
        cout << buffer << ": ";
        for (int j = 0; j < allSeqs[n].size(); j ++) 
            cout << allSeqs[n][j];
        cout << endl;
    }
    vector<int> lenSeqs (numSeq, 0);
    for (int n = 0; n < numSeq; n ++) 
        lenSeqs[n] = allSeqs[n].size();

    // 3. relaxed convex program: ADMM-based algorithm
    W = CVX_ADMM_MSA (allSeqs, lenSeqs);

    // 4. output the result
    /*
       cout << ">>>>>>>>>>>>>>>>>>>>>>>Summary<<<<<<<<<<<<<<<<<<<<<<<<" << endl;
       cout << "Length of Trace: " << trace.size();
       cout << ", Score: " << trace.back().score;
       cout << endl;
       int numInsertion = 0, numDeletion = 0, numMatch = 0, numMismatch = 0, numUndefined = 0;
       for (int i = 0; i < trace.size(); i ++) {
       switch (trace[i].action) {
       case MATCH: ++numMatch; break;
       case INSERTION: ++numInsertion; break;
       case DELETION: ++numDeletion; break;
       case MISMATCH: ++numMismatch; break;
       case UNDEFINED: ++numUndefined; break;
       }
       }
       cout << "numMatch: " << numMatch;
       cout << ", numInsertion: " << numInsertion;
       cout << ", numDeletion: " << numDeletion;
       cout << ", numMismatch: " << numMismatch;
       cout << ", numUndefined: " << numUndefined;
       cout << endl;
    // a. tuple view
    cout << ">>>>>>>>>>>>>>>>>>>>>>>TupleView<<<<<<<<<<<<<<<<<<<<<<<<" << endl;
    for (int i = 0; i < trace.size(); i ++) 
    cout << trace[i].toString() << endl;
    // b. sequence view
    cout << ">>>>>>>>>>>>>>>>>>>>>>>SequenceView<<<<<<<<<<<<<<<<<<<<<<<<" << endl;
    cout << "1st_aligned_DNA: ";
    for (int i = 0; i < trace.size(); i ++) 
    cout << trace[i].acidA;
    cout << endl;
    cout << "2nd_aligned_DNA: ";
    for (int i = 0; i < trace.size(); i ++) 
    cout << trace[i].acidB;
    cout << endl;
    */
    cout << "#########################################################" << endl;
    return 0;
}
