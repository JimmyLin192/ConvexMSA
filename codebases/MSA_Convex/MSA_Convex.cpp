/*###############################################################
## MODULE: MSA_Convex.cpp
## VERSION: 1.0 
## SINCE 2015-09-01
## DESCRIPTION: 
##      
#################################################################
## Edited by MacVim
## Class Info auto-generated by Snippet 
################################################################*/

#include "MSA_Convex.h"

/* Debugging option */
//#define RECURSION_TRACE

/* Define Scores and Other Constants */
const int MAX_FW_ITER = 100
const int MAX_ADMM_ITER = 1000;

const char GAP_NOTATION = '-';
const double C_I = 1; // penalty of insertion
const double C_D = 1; // penalty of deletion
const double C_MM = 1; // penalty of mismatch
const double C_M = 0; // penalty of match

const int INS_BASE_IDX = 0;
const int DEL_BASE_IDX = 1; // 1-A, 2-T, 3-C, 4-G
const int MTH_BASE_IDX = 5; // 5-A, 6-T, 7-C, 8-G
Action T4idx2Action [9] = {INSERTION,DELETION_A, DELETION_T, DELETION_C, DELETION_G, MATCH_A, MATCH_T, MATCH_C, MATCH_G};

int dna2T3idx (char dna) {
    switch (dna) {
        case 'A': return 0;
        case 'T': return 1;
        case 'C': return 2;
        case 'G': return 3;
    }
}

/* 
   The first sequence is observed. 
   The second sequence is the one to be aligned with the observed one.
   */
void usage () { cout << "./PSA_CUBE [seq_file]" << endl;
    cout << "seq_file should contain two DNA sequence in its first line and second line. " << endl;
    cout << "The first sequence is observed. " << endl;
    cout << "The second sequence is the one to be aligned with the observed one." << endl;
}

int get_init_model_length (vector<int>& lenSeqs) {
    int max_seq_length = -1;
    int numSeq = lenSeqs.size(); 
    for (int i = 0; i < numSeq; i ++)
        if (lenSeqs[i] > max_seq_length) 
            max_seq_length = lenSeqs[i];
    return max_seq_length;
}

void tensor5D_init (vector<Tensor4D>& C, SequenceSet& allSeqs, vector<int>& lenSeqs, int init_T2) {
    int numSeq = allSeqs.size();
    for (int n = 0; n < numSeq; n ++) {
        for (int i = 0; i < lenSeqs[n]; i ++) {
            Tensor tmp_tensor (init_T2, Matrix(NUM_DNA_TYPE, vector<double>(NUM_MOVEMENT, 0.0)));
            C[n].push_back(tmp_tensor);
        }
    }
}

/* Tensors auxiliary function */
/*{{{*/
void tensor4D_avg (Tensor4D& dest, Tensor4D& src1, Tensor4D& src2) {
    int T1 = src1.size();
    for (int i = 0; i < T1; i ++) {
        int T2 = src1[i].size();
        for (int j = 0; j < T2; j ++) 
            for (int d = 0; d < NUM_DNA_TYPE; d ++) 
                for (int m = 0; m < NUM_MOVEMENT; m ++)
                    dest[i][j][d][m] = 0.5*(src1[i][j][d][m] + src2[i][j][d][m]);
    }
}
void tensor4D_sub (Tensor4D& dest, Tensor4D& src1, Tensor4D& src2) {
    int T1 = src1.size();
    for (int i = 0; i < T1; i ++) {
        int T2 = src1[i].size();
        for (int j = 0; j < T2; j ++) 
            for (int d = 0; d < NUM_DNA_TYPE; d ++) 
                for (int m = 0; m < NUM_MOVEMENT; m ++)
                    dest[i][j][d][m] = src1[i][j][d][m] - src2[i][j][d][m];
    }
}
double tensor4D_frob_prod (Tensor4D& src1, Tensor4D& src2) {
    double prod = 0.0;
    int T1 = src1.size();
    for (int i = 0; i < T1; i ++) {
        int T2 = src1[i].size();
        for (int j = 0; j < T2; j ++) 
            for (int d = 0; d < NUM_DNA_TYPE; d ++) 
                for (int m = 0; m < NUM_MOVEMENT; m ++)
                    prod += src1[i][j][d][m] * src2[i][j][d][m];
    }
    return prod;
}
void tensor4D_lin_update (Tensor4D& dest, Tensor4D& src1, Tensor4D& src2, double& ratio) {
    int T1 = src1.size();
    for (int i = 0; i < T1; i ++) {
        int T2 = src1[i].size();
        for (int j = 0; j < T2; j ++) 
            for (int d = 0; d < NUM_DNA_TYPE; d ++) 
                for (int m = 0; m < NUM_MOVEMENT; m ++)
                    dest[i][j][d][m] += ratio * (src1[i][j][d][m] - src2[i][j][d][m]);
    }
}
void tensor4D_copy (Tensor4D& dest, Tensor4D& src1) {
    int N = src1.size();
    int T1 = src1.size();
    for (int i = 0; i < T1; i ++) {
        int T2 = src1[i].size();
        for (int j = 0; j < T2; j ++) 
            for (int d = 0; d < NUM_DNA_TYPE; d ++) 
                for (int m = 0; m < NUM_MOVEMENT; m ++)
                    dest[i][j][d][m] = src1[i][j][d][m];
    }
    return ;
}
/*}}}*/

/* 3-d smith waterman algorithm */
void cube_smith_waterman (Tensor4D& S, Trace& trace, Tensor4D& M, Tensor4D& C, Sequence& data_seq) {
/*{{{*/
    // 1. set up 3-d model
    int T1 = S.size() + 1;
    int T2 = S[0].size() + 1;
    int T3 = S[0][0].size();
    Cube cube (T1, Plane (T2, Trace (T3, Cell(3))));
    // 2. fill in the tensor
    double global_min_score = max_DOUBLE;
    int gmin_i = -1, gmin_j = -1, gmin_k = -1;
    for (int i = 0; i < T1; i ++) {
        for (int j = 0; j < T2; j ++) {
            for (int k = 0; k < T3; k ++) {
                cube[i][j][k].location[0] = i;
                cube[i][j][k].location[1] = j;
                cube[i][j][k].location[2] = k;
                if (i == 0 or j == 0) continue;
                vector<double> scores (NUM_MOVEMENT, 0.0); 
                // 1a. get insertion score
                double ins_score = cube[i][j-l][k].score + l * C_I;
                scores[INS_BASE_IDX] = ins_score;
                // 1b. get deletion score
                double del_score;
                for (int d = 0; d < NUM_DNA_TYPE ; d ++) {
                    del_score = cube[i][j-1][d].score + M[i][j][k][DEL_BASE_IDX+d] + C_D;
                    scores[DEL_BASE_IDX+d] = del_score;
                }
                // 1c. get max matach/mismatch score
                double mth_score;
                char data_dna = data_seq[i];
                double mscore = (dna2T3idx(data_dna)==k)?C_M:C_MM;
                for (int d = 0; d < NUM_DNA_TYPE ; d ++) {
                    mth_score = cube[i-1][j-1][d].score + M[i][j][k][MTH_BASE_IDX+d] + mscore; 
                    scores[MTH_BASE_IDX+d] = mth_score;
                }
                // 1d. get optimal action for the current cell
                double min_score = MAX_DOUBLE;
                Action min_action;
                char min_acidA, min_acidB;
                for (int mv = 0; mv < scores.size(); mv++) {
                    if (scores[mv] < min_score) {
                        min_score = scores[mv];
                        min_action = T4idx2Action[mv];
                    }
                }
                // 1e. assign the optimal score/action to the cell
                cube[i][j][k].score = min_score;
                cube[i][j][k].action = min_action;
                switch (cube[i][j][k].action) {
                    case INSERTION: 
                        cube[i][j][k].acidA = data_dna[i]; // data dna
                        cube[i][j][k].acidB = GAP_NOTATION; // model dna
                        break;
                    case DELETION_A: 
                        cube[i][j][k].acidA = data_dna[i]; 
                        cube[i][j][k].acidB = GAP_NOTATION; 
                        break;
                    case DELETION_T: 
                        cube[i][j][k].acidA = data_dna[i]; 
                        cube[i][j][k].acidB = GAP_NOTATION; 
                        break;
                    case DELETION_C: 
                        cube[i][j][k].acidA = data_dna[i]; 
                        cube[i][j][k].acidB = GAP_NOTATION; 
                        break;
                    case DELETION_G: 
                        cube[i][j][k].acidA = data_dna[i]; 
                        cube[i][j][k].acidB = GAP_NOTATION; 
                        break;
                    case MATCH_A: i--; j--; k = dna2T3idx(data_seq[i-1]); break;
                    case MATCH_T: i--; j--; k = dna2T3idx(data_seq[i-1]); break;
                    case MATCH_C: i--; j--; k = dna2T3idx(data_seq[i-1]); break;
                    case MATCH_G: i--; j--; k = dna2T3idx(data_seq[i-1]); break;
                    case UNDEFINED: cerr << "uncatched action." << endl; break;
                }
                // 1f. keep track of the globally optimal cell
                if (min_score <= global_min_score) {
                    global_min_score = min_score;
                    gmin_i = i;
                    gmin_j = j;
                    gmin_k = k;
                }
            }
        }
    }
    // 3. trace back
    cout << "min_i: " << gmin_i << ", min_j: " << gmin_j << ", min_k: " << gmin_k << endl;
    if (gmin_i == 0 or gmin_j == 0) {
        trace.push_back(cube[gmin_i][gmin_j][gmin_k]);
        return; 
    }
    int i,j;
    for (i = max_i, j = max_j; i > 0 and j > 0; ) {
        trace.insert(trace.begin(), cube[i][j][k]);
        switch (cube[i][j][k].action) {
            case INSERTION: i--; break;
            case DELETION_A: j--; k = dna2T3idx('A'); break;
            case DELETION_T: j--; k = dna2T3idx('T'); break;
            case DELETION_C: j--; k = dna2T3idx('C'); break;
            case DELETION_G: j--; k = dna2T3idx('G'); break;
            case MATCH_A: i--; j--; k = dna2T3idx(data_seq[i-1]); break;
            case MATCH_T: i--; j--; k = dna2T3idx(data_seq[i-1]); break;
            case MATCH_C: i--; j--; k = dna2T3idx(data_seq[i-1]); break;
            case MATCH_G: i--; j--; k = dna2T3idx(data_seq[i-1]); break;
            case UNDEFINED: cerr << "uncatched action." << endl; break;
        }
    }
    if (i == 0 and j == 0) return;
    else trace.insert(trace.begin(), cube[1][1][dna2T3idx(data_seq[0])]);
    // TODO: 4. reintepret it as 4-d data structure
    
/*}}}*/
}

void frank_wolfe_algo (Tensor4D& W, Tensor4D& Z, Tensor4D& Y, Tensor4D& C, double& mu, Sequence data_seq) {
/*{{{*/
    // 1. Find the update direction
    int T1 = W.size();
    int T2 = W[0].size();
    Tensor4D M (T1, Tensor(T2, Matrix(NUM_DNA_TYPE, vector<double>(NUM_MOVEMENT, 0.0)))); 
    int fw_iter;
    for (fw_iter < MAX_FW_ITER) {
        for (int i = 0; i < T1; i ++) 
            for (int j = 0; j < T2; j ++) 
                for (int d = 0; d < NUM_DNA_TYPE; d ++) 
                    for (int m = 0; m < NUM_MOVEMENT; m ++)
                        M[i][j][d][m] = mu*(W[i][j][d][m] - Z[i][j][d][m]) + Y[i][j][d][m]; 
        Tensor4D S (T1, Tensor(T2, Matrix(NUM_DNA_TYPE, vector<double>(NUM_MOVEMENT, 0.0)))); 
        Trace trace (0, Cell(3));
        cube_smith_waterman (S, trace, M, C, data_seq);

        // 2. Exact Line search: determine the optimal step size \alpha
        // alpha = { [ -(2/mu)*C - W + Z + (1/mu)*Y ] dot S } / || S ||^2
        //           ---------------combo------------------
        double s_square = tensor4D_frob_prod (S, S);
        double combo = 0.0;
        for (int i = 0; i < T1; i ++) 
            for (int j = 0; j < T2; j ++) 
                for (int d = 0; d < NUM_DNA_TYPE; d ++) 
                    for (int m = 0; m < NUM_MOVEMENT; m ++)
                        combo += ((-2.0*mu)/C[i][j][d][m] - W[i][j][d][m] + Z[i][j][d][m] + (1/mu)*Y[i][j][d][m]) * S[i][j][d][m];
        double alpha = combo / s_square;

        // 3. update W
        for (int i = 0; i < T1; i ++) 
            for (int j = 0; j < T2; j ++) 
                for (int d = 0; d < NUM_DNA_TYPE; d ++) 
                    for (int m = 0; m < NUM_MOVEMENT; m ++)
                        W[i][j][d][m] += alpha * S[i][j][d][m];
    }
    return; 
/*}}}*/
}

vector<Tensor4D> CVX_ADMM_MSA (SequenceSet& allSeqs, vector<int>& lenSeqs) {
/*{{{*/
    // 1. initialization
    int numSeq = allSeqs.size();
    int T2 = get_init_model_length (lenSeqs); // model_seq_length
    vector<Tensor4D> Z (numSeq, Tensor4D(0, Tensor(T2, Matrix(NUM_DNA_TYPE,
                        vector<double>(NUM_MOVEMENT, 0.0)))));  
    vector<Tensor4D> C (numSeq, Tensor4D(0, Tensor(T2, Matrix(NUM_DNA_TYPE,
                        vector<double>(NUM_MOVEMENT, 0.0)))));  
    vector<Tensor4D> W_1 (numSeq, Tensor4D(0, Tensor(T2, Matrix(NUM_DNA_TYPE,
                        vector<double>(NUM_MOVEMENT, 0.0)))));  
    vector<Tensor4D> W_2 (numSeq, Tensor4D(0, Tensor(T2, Matrix(NUM_DNA_TYPE,
                        vector<double>(NUM_MOVEMENT, 0.0)))));  
    vector<Tensor4D> Y_1 (numSeq, Tensor4D(0, Tensor(T2, Matrix(NUM_DNA_TYPE,
                        vector<double>(NUM_MOVEMENT, 0.0)))));  
    vector<Tensor4D> Y_2 (numSeq, Tensor4D(0, Tensor(T2, Matrix(NUM_DNA_TYPE,
                        vector<double>(NUM_MOVEMENT, 0.0)))));  
    tensor5D_init (Z, allSeqs, lenSeqs, T2);
    tensor5D_init (C, allSeqs, lenSeqs, T2);
    tensor5D_init (W_1, allSeqs, lenSeqs, T2);
    tensor5D_init (W_2, allSeqs, lenSeqs, T2);
    tensor5D_init (Y_1, allSeqs, lenSeqs, T2);
    tensor5D_init (Y_2, allSeqs, lenSeqs, T2);

    // 2. ADMM iteration
    int iter = 0;
    double mu = 1.0;
    for (iter < MAX_ADMM_ITER) {
        // 2a. Subprogram: FrankWolf Algorithm
        // NOTE: parallelize this for to enable parallelism
        for (int n = 0; n < numSeq; n++) 
            frank_wolfe (W_1[n], Z[n], Y_1[n], C[n], mu, allSeqs[i]);
        // 2b. Subprogram: 

        // 2c. update Z: Z = (W_1 + W_2) / 2
        // NOTE: parallelize this for to enable parallelism
        for (int n = 0; n < numSeq; n ++)
            tensor4D_average (Z[n], W_1[n], W_2[n]);
        // 2d. update Y_1 and Y_2: Y_1 += 1/mu * (W_1 - Z)
        // NOTE: parallelize this for to enable parallelism
        for (int n = 0; n < numSeq; n ++)
            tensor4D_lin_update (Y_1[n], W_1[n], Z[n], 1.0/mu);
        for (int n = 0; n < numSeq; n ++)
            tensor4D_lin_update (Y_2[n], W_2[n], Z[n], 1.0/mu);
    }
    return Z;
/*}}}*/
}

int main (int argn, char** argv) {
    // 1. usage
    if (argn < 2) {
        usage();
        exit(1);
    }

    // 2. input DNA sequence file
    SequenceSet allSeqs (0, Sequence());
    ifstream seq_file(argv[1]);
    string tmp_str;
    int numSeq = 0;
    while (getline(seq_file, tmp_str)) {
        Sequence tmp_seq (tmp_str.begin(), tmp_str.end());
        allSeqs.push_back(tmp_seq);
        ++ numSeq;
    }
    seq_file.close();
    cout << "#########################################################" << endl;
    cout << "ScoreMatch: " << MATCH_SCORE;
    cout << ", ScoreInsertion: " << INSERTION_SCORE;
    cout << ", ScoreDeletion: " << DELETION_SCORE;
    cout << ", ScoreMismatch: " << MISMATCH_SCORE << endl;
    for (int n = 0; n < numSeq; n ++) {
        char buffer [50];
        sprintf (buffer, "Seq%5d", n);
        cout << buffer << ": ";
        for (int j = 0; j < allSeqs[n].size(); j ++) 
            cout << allSeqs[n][j];
        cout << endl;
    }
    vector<int> lenSeqs (numSeq, 0);
    for (int n = 0; n < numSeq; n ++) 
        lenSeqs[n] = allSeqs[n].size();

    // 3. relaxed convex program: ADMM-based algorithm
    W = CVX_ADMM_MSA (allSeqs, lenSeqs);

    // 4. output the result
    /*
       cout << ">>>>>>>>>>>>>>>>>>>>>>>Summary<<<<<<<<<<<<<<<<<<<<<<<<" << endl;
       cout << "Length of Trace: " << trace.size();
       cout << ", Score: " << trace.back().score;
       cout << endl;
       int numInsertion = 0, numDeletion = 0, numMatch = 0, numMismatch = 0, numUndefined = 0;
       for (int i = 0; i < trace.size(); i ++) {
       switch (trace[i].action) {
       case MATCH: ++numMatch; break;
       case INSERTION: ++numInsertion; break;
       case DELETION: ++numDeletion; break;
       case MISMATCH: ++numMismatch; break;
       case UNDEFINED: ++numUndefined; break;
       }
       }
       cout << "numMatch: " << numMatch;
       cout << ", numInsertion: " << numInsertion;
       cout << ", numDeletion: " << numDeletion;
       cout << ", numMismatch: " << numMismatch;
       cout << ", numUndefined: " << numUndefined;
       cout << endl;
    // a. tuple view
    cout << ">>>>>>>>>>>>>>>>>>>>>>>TupleView<<<<<<<<<<<<<<<<<<<<<<<<" << endl;
    for (int i = 0; i < trace.size(); i ++) 
    cout << trace[i].toString() << endl;
    // b. sequence view
    cout << ">>>>>>>>>>>>>>>>>>>>>>>SequenceView<<<<<<<<<<<<<<<<<<<<<<<<" << endl;
    cout << "1st_aligned_DNA: ";
    for (int i = 0; i < trace.size(); i ++) 
    cout << trace[i].acidA;
    cout << endl;
    cout << "2nd_aligned_DNA: ";
    for (int i = 0; i < trace.size(); i ++) 
    cout << trace[i].acidB;
    cout << endl;
    */
    cout << "#########################################################" << endl;
    return 0;
}
