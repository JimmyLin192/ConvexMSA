/*###############################################################
## MODULE: test_CSW.cpp
## VERSION: 1.0 
## SINCE: 2015-09-05
##      
#################################################################
## Edited by MacVim
## Class Info auto-generated by Snippet 
################################################################*/

#include "MSA_Convex.h"

string seq_1 = "C";
string seq_2 = "AGT";
string seq_3 = "GAGTCAGCCTTGACCCTAGCT";

/* This file aims at making test on cube_smith_waterman */
int main (int argn, char** argv) {
    // 1. configure tested environment
    string data_dna(seq_3);
    int T1 = data_dna.length();
    int T2 = data_dna.length();
    int T3 = NUM_DNA_TYPE;
    int T4 = NUM_MOVEMENT;

    Tensor4D S(T1, Tensor(T2, Matrix(NUM_DNA_TYPE,
                    vector<double>(NUM_MOVEMENT, 0.0)))); // the resolved searching direction
    Trace trace(0, Cell(3));  // the resolved cell path
    Tensor4D M(T1, Tensor(T2, Matrix(NUM_DNA_TYPE,
                    vector<double>(NUM_MOVEMENT, 0.0)))); // pre-defined model preference
    Tensor4D C(T1, Tensor(T2, Matrix(NUM_DNA_TYPE,
                    vector<double>(NUM_MOVEMENT, 0.0)))); // global constant error
    Sequence data_seq(data_dna.begin(), data_dna.end()) ;  // data_seq for testing

    for (int d = 0; d < data_seq.size(); d ++)
        cout << data_seq[d] ;
    cout << endl;

    for (int i = 0; i < T1; i ++) {
        for (int j = 0; j < T2; j ++) {
            for (int k = 0; k < T3; k ++) {
                for (int m = 0; m < T4; m ++) {
                    if (m == INS_BASE_IDX) 
                        C[i][j][k][m] = C_I;
                    else if (DEL_BASE_IDX <= m and m < MTH_BASE_IDX) 
                        C[i][j][k][m] = C_D;
                    else if (MTH_BASE_IDX <= m and m < NUM_MOVEMENT) {
                        if (m == MTH_BASE_IDX+dna2T3idx(data_dna[i]))
                            C[i][j][k][m] = C_M;
                        else
                            C[i][j][k][m] = C_MM;
                    }
                }
            }
        }
    }

    // 2. invoke smith waterman algorithm
    cube_smith_waterman (S, trace, M, C, data_seq);

    // 3. show the result
    cout << ">>>>>>>>>>>>>>>>>>>>>>>Summary<<<<<<<<<<<<<<<<<<<<<<<<" << endl;
    cout << "ScoreMatch: " << C_M;
    cout << ", ScoreInsertion: " << C_I;
    cout << ", ScoreDeletion: " << C_D;
    cout << ", ScoreMismatch: " << C_MM << endl;
    cout << "Length of Trace: " << trace.size();
    cout << ", Score: " << trace.back().score;
    cout << endl;
    /*
    int numInsertion = 0, numDeletion = 0, numMatch = 0, numMismatch = 0, numUndefined = 0;
    for (int i = 0; i < trace.size(); i ++) {
        switch (trace[i].action) {
            case MATCH: ++numMatch; break;
            case INSERTION: ++numInsertion; break;
            case DELETION: ++numDeletion; break;
            case MISMATCH: ++numMismatch; break;
            case UNDEFINED: ++numUndefined; break;
        }
    }
    cout << "numMatch: " << numMatch;
    cout << ", numInsertion: " << numInsertion;
    cout << ", numDeletion: " << numDeletion;
    cout << ", numMismatch: " << numMismatch;
    cout << ", numUndefined: " << numUndefined;
    cout << endl;
    */

    // 3a. tuple view
    cout << ">>>>>>>>>>>>>>>>>>>>>>>TupleView<<<<<<<<<<<<<<<<<<<<<<<<" << endl;
    for (int i = 0; i < trace.size(); i ++) 
        cout << trace[i].toString() << endl;
    // 3b. sequence view
    cout << ">>>>>>>>>>>>>>>>>>>>>>>SequenceView<<<<<<<<<<<<<<<<<<<<<<<<" << endl;
    cout << "1st_aligned_DNA: ";
    for (int i = 0; i < trace.size(); i ++) 
        cout << trace[i].acidA;
    cout << endl;
    cout << "2nd_aligned_DNA: ";
    for (int i = 0; i < trace.size(); i ++) 
        cout << trace[i].acidB;
    cout << endl;
}

