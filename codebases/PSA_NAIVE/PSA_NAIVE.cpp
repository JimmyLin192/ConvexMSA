/*###############################################################
## MODULE: PSA_NAIVE.cpp
## VERSION: 1.0 
## SINCE 2015-08-29
##      
#################################################################
## Edited by MacVim
## Class Info auto-generated by Snippet 
################################################################*/

#include "stdio.h"
#include "stdlib.h"
#include <vector>
#include <iostream>
#include <fstream>
using namespace std;

/* Define penalities of each case */
const double MATCH_PENALTY = 0;
const double MISMATCH_PENALTY = 1;
const double INSERTION_PENALTY = 1;
const double DELETION_PENALTY = 1;

/* Define match identification function */
bool isMatch (char DNA1, char DNA2) {
    if (DNA1 > DNA2) {
        char temp = DNA1;
        DNA1 = DNA2;
        DNA2 = temp;
    }
    if (DNA1 == 'A' and DNA2 == 'T' or DNA1 == 'C' and DNA2 == 'G') 
        return true;
    else return false;
}

/* 
    The first sequence is observed. 
    The second sequence is the one to be aligned with the observed one.
*/
void usage () {
    cout << "./PSA_NAIVE [seq_file]" << endl;
    cout << "seq_file should contain two DNA sequence in its first line and second line. " << endl;
    cout << "The first sequence is observed. " << endl;
    cout << "The second sequence is the one to be aligned with the observed one." << endl;
}

class Tracker {
    double score;
    vector<char> aligned_seqA;
    vector<char> aligned_seqB;
    Tracker () {
        this.score = 0;
    }
    Tracker (Tracker tr) {
        this.score = tr.score;
        this.aligned_seqA = tr.aligned_seqA;
        this.aligned_seqB = tr.aligned_seqB;
    }
    Tracker (double score, vector<char> aligned_seqA, vector<char> aligned_seqB) {
        this.score = score;
        this.aligned_seqA = aligned_seqA;
        this.aligned_seqB = aligned_seqB;
    }
}

Tracker align (vector<char>& seqA, vector<char>& seqB, int posA, int posB, Tracker tr) {
    int lenA = seqA.size();
    int lenB = seqB.size();
    int remlenA = lenA - posA - 1;
    int remlenB = lenB - posB - 1;
    // 1. termination criteria
    if (remlenA == 0 and remlenB == 0) {
        return tr;
    } else if (remlenA == 0 and remlenB == 1) {
        // deletion
        tr.score += DELETION_PENALTY;
        tr.aligned_seqA.push_back('-');
        tr.aligned_seqB.push_back(seqB[posB])
        return tr;
    } else if (remlenA == 1 and remlenB == 0) {
        // insertion
        tr.score += INSERTION_PENALTY;
        tr.aligned_seqA.push_back(seqA[posA])
        tr.aligned_seqB.push_back('-');
        return tr;   
    }
    // 2. invoke recursion to achieve dynamic programming
    

    // 3. compare trackers and return the best one

}

int main (int argn, char** argv) {
    // 1. usage
    if (argn < 2) {
        usage();
        exit(1);
    }
    // 2. input DNA sequence file
    ifstream seq_file(argv[1]);
    string primary_DNA, secondary_DNA;
    getline(seq_file, primary_DNA);
    getline(seq_file, secondary_DNA);
    seq_file.close();
    cout << "###############################################"
    cout << "1st_DNA: " << primary_DNA << endl;
    cout << "2nd_DNA: " << secondary_DNA << endl;
    cout << ">>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<"
    // 3. process dynamic programming
    vector<char> seqA (primary_DNA.begin(), primary_DNA.end());
    vector<char> seqB (secondary_DNA.begin(), secondary_DNA.end());
    Tracker init_tr ();
    Tracker out_tr (align(seqA, seqB, 0, 0, init_tr));
    // 4. output the result
    cout << "Penalty (Score): " << out_tr.score << endl;
    cout << "1st_aligned_DNA: " << out_tr.aligned_seqA << endl;
    cout << "2nd_aligned_DNA: " << out_tr.aligned_seqB << endl;
    cout << "###############################################"
    return 0;
}
